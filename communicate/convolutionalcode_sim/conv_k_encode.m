%% 本函数实现卷积编码
%{
输入：
    原始序列m
    生成矢量G  元组 每一个细胞对应一个输入的生成式 输入（1，k）
输出：
    卷积码结果C 
特点：
    适用于所有的[n,k,N]卷积编码
%}

function C = conv_k_encode(m,G)
len = length(m);    %记录输入信息长度
[~,k] = size(G);    %k表示每次输入的信息码元数

if (mod(len,k)~=0)  %说明最后一次输入的时候信息码不够 
    times = len/k + 1; %time 为循环次数
else
    times =len/k;
end

%times

m = [m,zeros(1,k)];    %这样总可以让最后一次输入时有k个信息码输入 防止最后一次循环没有输入报错

%预先分配内存 加快运行速度
n = zeros(1,k);     %共有k个 每一个表示一个输入对应的编码器结构
N = zeros(1,k);     %不过每个码元对应的输出码元数肯定相同 所以n（i）均相同 
for i=1:k           %求每次输入码元对应的编码器结构
    [n(i),N(i)] = size(G{i}); %n表示一次有几个码元输出 N表示一次有几个监督码元（包括当前输入）
end

C = zeros(1,n(1)*floor(times));%每次循环输出n(1)个码元 
%C1 = zeros(1,n(1));%暂时存储每个输入码元对应的输出码元
C_regs = cell(1,k);  %k个输入 对应k个编码器结构
%初始化每个输入对应的寄存器状态 并送入新的输入
for i=1:k 
    C_regs{i} = [m(i),zeros(1,N(i)-1)]; %对应[输入,m个初始为零的状态] 
end

for i=1:floor(times)    %开始循环 将每一次的k个输入都得到其对应的输出
    for j=1:k       %对每个输入进行循环 得到C的值
        C1 = mod(C_regs{j}*G{j}',2); %得到第i次输入时第j个码元的输入结果
        %上一个输入码元对应的输出加上此时码元对应的输入码元异或（对2取余），则为此时全部输入对应的输入码元
        C((i-1)*n(j)+1:n(j)*i) = mod(C1+C((i-1)*n(j)+1:n(j)*i),2);
        %载入新的输入并更新寄存器状态 为下一次的大循环的第j个码元的编码器做准备
        C_regs{j} = [m(j+i*k),C_regs{j}];%此时（1，k+1）
        C_regs{j}(end) = [];% 挤掉旧符号 最后一个元素直接没有 回到（1，k）
    end
end
