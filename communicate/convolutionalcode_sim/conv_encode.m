%% 本函数实现卷积编码
%{
输入：
    原始序列m
    生成矢量G  每一行代表一个输出的连接结构
输出：
    卷积码结果C 
特点：
    适用于所有的[n,1,N]卷积编码
%}
function C = conv_encode(m,G)
len = length(m);    %记录输入信息长度
k=1;                %每次输入一个码元
[n,N] =  size(G);   %n表示一次有几个码元输出 N表示一次有几个监督码元（包括当前输入）
C = zeros(1,n*len); %储存输出卷积码

%在头尾补0，方便卷积输出和寄存器清洗
m_add0 = [zeros(1,N-1),m,0]; %初始m个状态均假设为0，补N-1个0 当作新的信息流
%fliplr将矩阵倒序 因为编码器输出的计算是对应的 [输入-m个状态].*G 而m_add0中与所需相反
C_reg = fliplr(m_add0(1,1:N));  %C_reg[输入-m个状态] 因为每次监督的码元为N个，故寄存器中也储存N个码元

%开始循环 将每一个输入都得到对应的输出
for i=1:len
    %生成每一位输入符号的n位输出
    % C(n*i-(n-1):n*i) =  mod(C_reg*G',2);
    C(n*(i-1)+1:n*i) =  mod(C_reg*G',2);
    %载入新的输入并更新寄存器状态 
    C_reg = [m_add0(i+N),C_reg];%此时（1，N+1）
    C_reg(end) = [];% 挤掉旧符号 最后一个元素直接没有 回到（1，N）
end
